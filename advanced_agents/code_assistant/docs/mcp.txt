# Model Context Protocol (MCP) Development Guide

## Understanding Model Context Protocol (MCP)

### Core Concepts
MCP is Microsoft's protocol designed to standardize how AI models communicate with external tools, systems, and data sources. It provides:

- **Standardized Communication**: Consistent interface between models and tools
- **Tool Integration**: Seamless connection to external services and APIs
- **Context Management**: Efficient handling of conversation state and memory
- **Security**: Built-in authentication and permission management
- **Scalability**: Support for distributed and multi-agent systems

### MCP Architecture Components
1. **MCP Server**: Hosts tools and resources
2. **MCP Client**: Consumes tools and resources (typically the AI model)
3. **Transport Layer**: Handles communication (HTTP, WebSocket, stdio)
4. **Protocol Layer**: Defines message format and semantics
5. **Tool Layer**: Implements actual functionality

## MCP Protocol Implementation

### Basic MCP Server Structure
```python
import asyncio
import json
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from abc import ABC, abstractmethod
from enum import Enum
import logging

class MCPMessageType(Enum):
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"

class MCPErrorCode(Enum):
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603

@dataclass
class MCPMessage:
    """Base MCP message structure"""
    jsonrpc: str = "2.0"
    id: Optional[Union[str, int]] = None
    
@dataclass
class MCPRequest(MCPMessage):
    """MCP request message"""
    method: str
    params: Optional[Dict[str, Any]] = None

@dataclass
class MCPResponse(MCPMessage):
    """MCP response message"""
    result: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None

@dataclass
class MCPNotification(MCPMessage):
    """MCP notification message"""
    method: str
    params: Optional[Dict[str, Any]] = None

class MCPError(Exception):
    """MCP-specific error"""
    def __init__(self, code: MCPErrorCode, message: str, data: Any = None):
        self.code = code
        self.message = message
        self.data = data
        super().__init__(message)
    
    def to_dict(self) -> Dict[str, Any]:
        error_dict = {
            "code": self.code.value,
            "message": self.message
        }
        if self.data is not None:
            error_dict["data"] = self.data
        return error_dict

class MCPToolResult:
    """Result from tool execution"""
    def __init__(self, content: List[Dict[str, Any]], is_error: bool = False):
        self.content = content
        self.is_error = is_error
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "content": self.content,
            "isError": self.is_error
        }

class MCPTool(ABC):
    """Abstract base class for MCP tools"""
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        pass
    
    @property
    @abstractmethod
    def input_schema(self) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    async def execute(self, arguments: Dict[str, Any]) -> MCPToolResult:
        pass

class MCPResource(ABC):
    """Abstract base class for MCP resources"""
    
    @property
    @abstractmethod
    def uri(self) -> str:
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        pass
    
    @property
    @abstractmethod
    def mime_type(self) -> str:
        pass
    
    @abstractmethod
    async def read(self) -> Dict[str, Any]:
        pass

class MCPServer:
    """MCP Server implementation"""
    
    def __init__(self, name: str, version: str):
        self.name = name
        self.version = version
        self.tools: Dict[str, MCPTool] = {}
        self.resources: Dict[str, MCPResource] = {}
        self.capabilities = {
            "tools": {},
            "resources": {},
            "prompts": {}
        }
        self.logger = logging.getLogger(__name__)
    
    def register_tool(self, tool: MCPTool):
        """Register a tool with the server"""
        self.tools[tool.name] = tool
        self.capabilities["tools"] = {"listChanged": True}
        self.logger.info(f"Registered tool: {tool.name}")
    
    def register_resource(self, resource: MCPResource):
        """Register a resource with the server"""
        self.resources[resource.uri] = resource
        self.capabilities["resources"] = {"subscribe": True, "listChanged": True}
        self.logger.info(f"Registered resource: {resource.uri}")
    
    async def handle_request(self, request: MCPRequest) -> MCPResponse:
        """Handle incoming MCP request"""
        try:
            if request.method == "initialize":
                return await self._handle_initialize(request)
            elif request.method == "tools/list":
                return await self._handle_tools_list(request)
            elif request.method == "tools/call":
                return await self._handle_tools_call(request)
            elif request.method == "resources/list":
                return await self._handle_resources_list(request)
            elif request.method == "resources/read":
                return await self._handle_resources_read(request)
            else:
                raise MCPError(
                    MCPErrorCode.METHOD_NOT_FOUND,
                    f"Method not found: {request.method}"
                )
        
        except MCPError as e:
            return MCPResponse(id=request.id, error=e.to_dict())
        except Exception as e:
            self.logger.exception(f"Unexpected error handling request: {request.method}")
            error = MCPError(MCPErrorCode.INTERNAL_ERROR, str(e))
            return MCPResponse(id=request.id, error=error.to_dict())
    
    async def _handle_initialize(self, request: MCPRequest) -> MCPResponse:
        """Handle initialization request"""
        client_info = request.params or {}
        
        result = {
            "protocolVersion": "2024-11-05",
            "capabilities": self.capabilities,
            "serverInfo": {
                "name": self.name,
                "version": self.version
            }
        }
        
        return MCPResponse(id=request.id, result=result)
    
    async def _handle_tools_list(self, request: MCPRequest) -> MCPResponse:
        """Handle tools list request"""
        tools_list = []
        for tool in self.tools.values():
            tools_list.append({
                "name": tool.name,
                "description": tool.description,
                "inputSchema": tool.input_schema
            })
        
        return MCPResponse(id=request.id, result={"tools": tools_list})
    
    async def _handle_tools_call(self, request: MCPRequest) -> MCPResponse:
        """Handle tool call request"""
        params = request.params or {}
        tool_name = params.get("name")
        arguments = params.get("arguments", {})
        
        if tool_name not in self.tools:
            raise MCPError(
                MCPErrorCode.INVALID_PARAMS,
                f"Tool not found: {tool_name}"
            )
        
        tool = self.tools[tool_name]
        result = await tool.execute(arguments)
        
        return MCPResponse(id=request.id, result=result.to_dict())
    
    async def _handle_resources_list(self, request: MCPRequest) -> MCPResponse:
        """Handle resources list request"""
        resources_list = []
        for resource in self.resources.values():
            resources_list.append({
                "uri": resource.uri,
                "name": resource.name,
                "description": resource.description,
                "mimeType": resource.mime_type
            })
        
        return MCPResponse(id=request.id, result={"resources": resources_list})
    
    async def _handle_resources_read(self, request: MCPRequest) -> MCPResponse:
        """Handle resource read request"""
        params = request.params or {}
        uri = params.get("uri")
        
        if uri not in self.resources:
            raise MCPError(
                MCPErrorCode.INVALID_PARAMS,
                f"Resource not found: {uri}"
            )
        
        resource = self.resources[uri]
        content = await resource.read()
        
        return MCPResponse(id=request.id, result={"contents": [content]})
```

### Concrete Tool Implementations
```python
import os
import subprocess
import tempfile
import json
import requests
from pathlib import Path

class FileSystemTool(MCPTool):
    """Tool for file system operations"""
    
    @property
    def name(self) -> str:
        return "filesystem"
    
    @property
    def description(self) -> str:
        return "Read, write, and manipulate files and directories"
    
    @property
    def input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "enum": ["read", "write", "list", "delete", "create_dir"],
                    "description": "The operation to perform"
                },
                "path": {
                    "type": "string",
                    "description": "File or directory path"
                },
                "content": {
                    "type": "string",
                    "description": "Content to write (for write operation)"
                }
            },
            "required": ["operation", "path"]
        }
    
    async def execute(self, arguments: Dict[str, Any]) -> MCPToolResult:
        operation = arguments["operation"]
        path = Path(arguments["path"])
        
        try:
            if operation == "read":
                if not path.exists():
                    return MCPToolResult(
                        [{"type": "text", "text": f"File not found: {path}"}],
                        is_error=True
                    )
                
                content = path.read_text(encoding='utf-8')
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Content of {path}:\n{content}"
                }])
            
            elif operation == "write":
                content = arguments.get("content", "")
                path.parent.mkdir(parents=True, exist_ok=True)
                path.write_text(content, encoding='utf-8')
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Successfully wrote to {path}"
                }])
            
            elif operation == "list":
                if not path.exists():
                    return MCPToolResult(
                        [{"type": "text", "text": f"Directory not found: {path}"}],
                        is_error=True
                    )
                
                items = []
                for item in path.iterdir():
                    item_type = "directory" if item.is_dir() else "file"
                    items.append(f"{item.name} ({item_type})")
                
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Contents of {path}:\n" + "\n".join(items)
                }])
            
            elif operation == "delete":
                if path.exists():
                    if path.is_file():
                        path.unlink()
                    else:
                        path.rmdir()
                    return MCPToolResult([{
                        "type": "text",
                        "text": f"Successfully deleted {path}"
                    }])
                else:
                    return MCPToolResult([{
                        "type": "text",
                        "text": f"Path not found: {path}"
                    }])
            
            elif operation == "create_dir":
                path.mkdir(parents=True, exist_ok=True)
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Successfully created directory {path}"
                }])
        
        except Exception as e:
            return MCPToolResult(
                [{"type": "text", "text": f"Error: {str(e)}"}],
                is_error=True
            )

class CodeExecutionTool(MCPTool):
    """Tool for executing code safely"""
    
    @property
    def name(self) -> str:
        return "code_execution"
    
    @property
    def description(self) -> str:
        return "Execute Python code in a safe environment"
    
    @property
    def input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "Python code to execute"
                },
                "timeout": {
                    "type": "integer",
                    "default": 30,
                    "description": "Execution timeout in seconds"
                }
            },
            "required": ["code"]
        }
    
    async def execute(self, arguments: Dict[str, Any]) -> MCPToolResult:
        code = arguments["code"]
        timeout = arguments.get("timeout", 30)
        
        # Create temporary file for code execution
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(code)
            temp_file = f.name
        
        try:
            # Execute code with timeout
            result = subprocess.run(
                ['python', temp_file],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Code executed successfully:\n{result.stdout}"
                }])
            else:
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Code execution failed:\n{result.stderr}"
                }], is_error=True)
        
        except subprocess.TimeoutExpired:
            return MCPToolResult([{
                "type": "text",
                "text": f"Code execution timed out after {timeout} seconds"
            }], is_error=True)
        
        except Exception as e:
            return MCPToolResult([{
                "type": "text",
                "text": f"Execution error: {str(e)}"
            }], is_error=True)
        
        finally:
            # Clean up temporary file
            os.unlink(temp_file)

class WebAPITool(MCPTool):
    """Tool for making HTTP requests"""
    
    @property
    def name(self) -> str:
        return "web_api"
    
    @property
    def description(self) -> str:
        return "Make HTTP requests to web APIs"
    
    @property
    def input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "method": {
                    "type": "string",
                    "enum": ["GET", "POST", "PUT", "DELETE"],
                    "description": "HTTP method"
                },
                "url": {
                    "type": "string",
                    "description": "URL to request"
                },
                "headers": {
                    "type": "object",
                    "description": "HTTP headers"
                },
                "data": {
                    "type": "object",
                    "description": "Request body data"
                },
                "timeout": {
                    "type": "integer",
                    "default": 30,
                    "description": "Request timeout in seconds"
                }
            },
            "required": ["method", "url"]
        }
    
    async def execute(self, arguments: Dict[str, Any]) -> MCPToolResult:
        method = arguments["method"]
        url = arguments["url"]
        headers = arguments.get("headers", {})
        data = arguments.get("data")
        timeout = arguments.get("timeout", 30)
        
        try:
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                json=data,
                timeout=timeout
            )
            
            result_text = f"Status: {response.status_code}\n"
            result_text += f"Headers: {dict(response.headers)}\n"
            
            try:
                json_data = response.json()
                result_text += f"JSON Response: {json.dumps(json_data, indent=2)}"
            except:
                result_text += f"Text Response: {response.text[:1000]}"
            
            return MCPToolResult([{
                "type": "text",
                "text": result_text
            }])
        
        except Exception as e:
            return MCPToolResult([{
                "type": "text",
                "text": f"HTTP request failed: {str(e)}"
            }], is_error=True)

class DatabaseTool(MCPTool):
    """Tool for database operations"""
    
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
    
    @property
    def name(self) -> str:
        return "database"
    
    @property
    def description(self) -> str:
        return "Execute SQL queries on database"
    
    @property
    def input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "SQL query to execute"
                },
                "operation": {
                    "type": "string",
                    "enum": ["select", "insert", "update", "delete"],
                    "description": "Type of SQL operation"
                }
            },
            "required": ["query", "operation"]
        }
    
    async def execute(self, arguments: Dict[str, Any]) -> MCPToolResult:
        query = arguments["query"]
        operation = arguments["operation"]
        
        # This is a simplified example - in practice, you'd use proper database libraries
        # like SQLAlchemy, psycopg2, etc.
        
        try:
            # Simulate database operation
            if operation == "select":
                # Simulate SELECT results
                results = [
                    {"id": 1, "name": "Example", "value": 100},
                    {"id": 2, "name": "Sample", "value": 200}
                ]
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Query results:\n{json.dumps(results, indent=2)}"
                }])
            else:
                # Simulate INSERT/UPDATE/DELETE
                return MCPToolResult([{
                    "type": "text",
                    "text": f"Successfully executed {operation.upper()} query"
                }])
        
        except Exception as e:
            return MCPToolResult([{
                "type": "text",
                "text": f"Database error: {str(e)}"
            }], is_error=True)
```

### MCP Resource Implementations
```python
class FileResource(MCPResource):
    """Resource for accessing files"""
    
    def __init__(self, file_path: str, name: str = None):
        self.file_path = Path(file_path)
        self._name = name or self.file_path.name
    
    @property
    def uri(self) -> str:
        return f"file://{self.file_path.absolute()}"
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def description(self) -> str:
        return f"File resource: {self.file_path}"
    
    @property
    def mime_type(self) -> str:
        suffix = self.file_path.suffix.lower()
        mime_types = {
            '.txt': 'text/plain',
            '.md': 'text/markdown',
            '.py': 'text/x-python',
            '.js': 'text/javascript',
            '.json': 'application/json',
            '.html': 'text/html',
            '.css': 'text/css'
        }
        return mime_types.get(suffix, 'application/octet-stream')
    
    async def read(self) -> Dict[str, Any]:
        try:
            content = self.file_path.read_text(encoding='utf-8')
            return {
                "uri": self.uri,
                "mimeType": self.mime_type,
                "text": content
            }
        except Exception as e:
            return {
                "uri": self.uri,
                "mimeType": "text/plain",
                "text": f"Error reading file: {str(e)}"
            }

class DirectoryResource(MCPResource):
    """Resource for accessing directory contents"""
    
    def __init__(self, dir_path: str, name: str = None):
        self.dir_path = Path(dir_path)
        self._name = name or self.dir_path.name
    
    @property
    def uri(self) -> str:
        return f"directory://{self.dir_path.absolute()}"
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def description(self) -> str:
        return f"Directory resource: {self.dir_path}"
    
    @property
    def mime_type(self) -> str:
        return "application/json"
    
    async def read(self) -> Dict[str, Any]:
        try:
            items = []
            for item in self.dir_path.iterdir():
                items.append({
                    "name": item.name,
                    "type": "directory" if item.is_dir() else "file",
                    "size": item.stat().st_size if item.is_file() else None,
                    "modified": item.stat().st_mtime
                })
            
            return {
                "uri": self.uri,
                "mimeType": self.mime_type,
                "text": json.dumps({
                    "path": str(self.dir_path),
                    "items": items
                }, indent=2)
            }
        except Exception as e:
            return {
                "uri": self.uri,
                "mimeType": "text/plain",
                "text": f"Error reading directory: {str(e)}"
            }

class APIResource(MCPResource):
    """Resource for accessing API endpoints"""
    
    def __init__(self, api_url: str, name: str, headers: Dict[str, str] = None):
        self.api_url = api_url
        self._name = name
        self.headers = headers or {}
    
    @property
    def uri(self) -> str:
        return f"api://{self.api_url}"
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def description(self) -> str:
        return f"API resource: {self.api_url}"
    
    @property
    def mime_type(self) -> str:
        return "application/json"
    
    async def read(self) -> Dict[str, Any]:
        try:
            response = requests.get(self.api_url, headers=self.headers, timeout=30)
            response.raise_for_status()
            
            return {
                "uri": self.uri,
                "mimeType": self.mime_type,
                "text": response.text
            }
        except Exception as e:
            return {
                "uri": self.uri,
                "mimeType": "text/plain",
                "text": f"Error accessing API: {str(e)}"
            }
```

### MCP Client Implementation
```python
class MCPClient:
    """MCP Client for consuming server capabilities"""
    
    def __init__(self, server_url: str = None):
        self.server_url = server_url
        self.session_id = None
        self.capabilities = {}
        self.tools = {}
        self.resources = {}
        self.logger = logging.getLogger(__name__)
    
    async def initialize(self, client_info: Dict[str, Any]) -> Dict[str, Any]:
        """Initialize connection with MCP server"""
        request = MCPRequest(
            id="init-1",
            method="initialize",
            params=client_info
        )
        
        response = await self._send_request(request)
        if response.error:
            raise MCPError(
                MCPErrorCode.INTERNAL_ERROR,
                f"Initialization failed: {response.error}"
            )
        
        self.capabilities = response.result.get("capabilities", {})
        return response.result
    
    async def list_tools(self) -> List[Dict[str, Any]]:
        """Get list of available tools"""
        request = MCPRequest(id="tools-1", method="tools/list")
        response = await self._send_request(request)
        
        if response.error:
            raise MCPError(
                MCPErrorCode.INTERNAL_ERROR,
                f"Failed to list tools: {response.error}"
            )
        
        tools = response.result.get("tools", [])
        self.tools = {tool["name"]: tool for tool in tools}
        return tools
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Call a specific tool"""
        if tool_name not in self.tools:
            available_tools = await self.list_tools()
            if tool_name not in self.tools:
                raise MCPError(
                    MCPErrorCode.INVALID_PARAMS,
                    f"Tool '{tool_name}' not found. Available: {list(self.tools.keys())}"
                )
        
        request = MCPRequest(
            id=f"tool-call-{tool_name}",
            method="tools/call",
            params={"name": tool_name, "arguments": arguments}
        )
        
        response = await self._send_request(request)
        if response.error:
            raise MCPError(
                MCPErrorCode.INTERNAL_ERROR,
                f"Tool call failed: {response.error}"
            )
        
        return response.result
    
    async def list_resources(self) -> List[Dict[str, Any]]:
        """Get list of available resources"""
        request = MCPRequest(id="resources-1", method="resources/list")
        response = await self._send_request(request)
        
        if response.error:
            raise MCPError(
                MCPErrorCode.INTERNAL_ERROR,
                f"Failed to list resources: {response.error}"
            )
        
        resources = response.result.get("resources", [])
        self.resources = {resource["uri"]: resource for resource in resources}
        return resources
    
    async def read_resource(self, uri: str) -> Dict[str, Any]:
        """Read a specific resource"""
        request = MCPRequest(
            id=f"resource-read-{uri}",
            method="resources/read",
            params={"uri": uri}
        )
        
        response = await self._send_request(request)
        if response.error:
            raise MCPError(
                MCPErrorCode.INTERNAL_ERROR,
                f"Resource read failed: {response.error}"
            )
        
        return response.result
    
    async def _send_request(self, request: MCPRequest) -> MCPResponse:
        """Send request to MCP server"""
        # This is a simplified implementation
        # In practice, this would use actual transport (HTTP, WebSocket, etc.)
        
        # For demo purposes, we'll simulate server response
        if request.method == "initialize":
            return MCPResponse(
                id=request.id,
                result={
                    "protocolVersion": "2024-11-05",
                    "capabilities": {"tools": {}, "resources": {}},
                    "serverInfo": {"name": "Demo Server", "version": "1.0.0"}
                }
            )
        
        # Add other method handlers as needed
        return MCPResponse(
            id=request.id,
            result={"status": "simulated"}
        )

# Complete MCP Application Example
class MCPCodeAssistant:
    """Complete code assistant using MCP"""
    
    def __init__(self):
        self.server = MCPServer("CodeAssistant", "1.0.0")
        self.client = MCPClient()
        self._setup_tools_and_resources()
    
    def _setup_tools_and_resources(self):
        """Setup all tools and resources"""
        # Register tools
        self.server.register_tool(FileSystemTool())
        self.server.register_tool(CodeExecutionTool())
        self.server.register_tool(WebAPITool())
        
        # Register resources
        self.server.register_resource(FileResource("README.md"))
        self.server.register_resource(DirectoryResource("."))
    
    async def process_request(self, user_request: str) -> str:
        """Process user request using MCP tools"""
        
        # Analyze request to determine needed tools
        if "file" in user_request.lower() or "read" in user_request.lower():
            # Use filesystem tool
            result = await self.client.call_tool("filesystem", {
                "operation": "read",
                "path": "example.py"
            })
            return f"File operation result: {result}"
        
        elif "execute" in user_request.lower() or "run" in user_request.lower():
            # Use code execution tool
            code = self._extract_code_from_request(user_request)
            result = await self.client.call_tool("code_execution", {
                "code": code
            })
            return f"Code execution result: {result}"
        
        elif "api" in user_request.lower() or "http" in user_request.lower():
            # Use web API tool
            result = await self.client.call_tool("web_api", {
                "method": "GET",
                "url": "https://httpbin.org/json"
            })
            return f"API call result: {result}"
        
        else:
            return "I'm not sure how to help with that request."
    
    def _extract_code_from_request(self, request: str) -> str:
        """Extract code from user request"""
        # Simple extraction - in practice, use more sophisticated parsing
        if "```python" in request:
            start = request.find("```python") + 9
            end = request.find("```", start)
            return request[start:end].strip()
        
        return "print('Hello, World!')"  # Default code

# Usage example
async def main():
    """Main function demonstrating MCP usage"""
    assistant = MCPCodeAssistant()
    
    # Initialize client
    await assistant.client.initialize({
        "clientInfo": {"name": "Test Client", "version": "1.0.0"}
    })
    
    # Test requests
    requests = [
        "Read the README.md file",
        "Execute this code: print('Hello MCP!')",
        "Make an API call to get JSON data"
    ]
    
    for request in requests:
        try:
            result = await assistant.process_request(request)
            print(f"Request: {request}")
            print(f"Result: {result}\n")
        except Exception as e:
            print(f"Error processing '{request}': {e}\n")

# Uncomment to run example
# asyncio.run(main())
```

### MCP Security and Best Practices
```python
import hashlib
import hmac
import time
from typing import Set
import jwt

class MCPSecurity:
    """Security utilities for MCP implementations"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.rate_limits: Dict[str, List[float]] = {}
        self.allowed_origins: Set[str] = set()
        self.api_keys: Dict[str, Dict[str, Any]] = {}
    
    def generate_api_key(self, client_id: str, permissions: List[str]) -> str:
        """Generate API key for client"""
        key_data = {
            "client_id": client_id,
            "permissions": permissions,
            "issued_at": time.time()
        }
        
        api_key = jwt.encode(key_data, self.secret_key, algorithm="HS256")
        self.api_keys[api_key] = key_data
        return api_key
    
    def validate_api_key(self, api_key: str) -> Dict[str, Any]:
        """Validate API key and return client info"""
        try:
            payload = jwt.decode(api_key, self.secret_key, algorithms=["HS256"])
            return payload
        except jwt.InvalidTokenError:
            raise MCPError(MCPErrorCode.INVALID_REQUEST, "Invalid API key")
    
    def check_rate_limit(self, client_id: str, limit: int = 100, window: int = 3600) -> bool:
        """Check if client is within rate limits"""
        current_time = time.time()
        
        if client_id not in self.rate_limits:
            self.rate_limits[client_id] = []
        
        # Clean old requests
        self.rate_limits[client_id] = [
            req_time for req_time in self.rate_limits[client_id]
            if current_time - req_time < window
        ]
        
        # Check limit
        if len(self.rate_limits[client_id]) >= limit:
            return False
        
        self.rate_limits[client_id].append(current_time)
        return True
    
    def validate_origin(self, origin: str) -> bool:
        """Validate request origin"""
        return origin in self.allowed_origins or "*" in self.allowed_origins
    
    def sign_message(self, message: str) -> str:
        """Sign message with HMAC"""
        return hmac.new(
            self.secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def verify_signature(self, message: str, signature: str) -> bool:
        """Verify message signature"""
        expected_signature = self.sign_message(message)
        return hmac.compare_digest(expected_signature, signature)

class SecureMCPServer(MCPServer):
    """MCP Server with security features"""
    
    def __init__(self, name: str, version: str, secret_key: str):
        super().__init__(name, version)
        self.security = MCPSecurity(secret_key)
        self.require_auth = True
    
    async def handle_request(self, request: MCPRequest, headers: Dict[str, str] = None) -> MCPResponse:
        """Handle request with security checks"""
        headers = headers or {}
        
        # Check authentication
        if self.require_auth and request.method != "initialize":
            auth_header = headers.get("Authorization", "")
            if not auth_header.startswith("Bearer "):
                return MCPResponse(
                    id=request.id,
                    error=MCPError(MCPErrorCode.INVALID_REQUEST, "Missing authentication").to_dict()
                )
            
            api_key = auth_header[7:]  # Remove "Bearer " prefix
            try:
                client_info = self.security.validate_api_key(api_key)
                client_id = client_info["client_id"]
                
                # Check rate limits
                if not self.security.check_rate_limit(client_id):
                    return MCPResponse(
                        id=request.id,
                        error=MCPError(MCPErrorCode.INVALID_REQUEST, "Rate limit exceeded").to_dict()
                    )
                
            except MCPError as e:
                return MCPResponse(id=request.id, error=e.to_dict())
        
        # Process request normally
        return await super().handle_request(request)

# Deployment and monitoring utilities
class MCPMonitoring:
    """Monitoring and metrics for MCP servers"""
    
    def __init__(self):
        self.metrics = {
            "requests_total": 0,
            "requests_by_method": {},
            "errors_total": 0,
            "response_times": [],
            "active_connections": 0
        }
        self.start_time = time.time()
    
    def record_request(self, method: str, response_time: float, success: bool):
        """Record request metrics"""
        self.metrics["requests_total"] += 1
        self.metrics["requests_by_method"][method] = self.metrics["requests_by_method"].get(method, 0) + 1
        self.metrics["response_times"].append(response_time)
        
        if not success:
            self.metrics["errors_total"] += 1
        
        # Keep only last 1000 response times
        if len(self.metrics["response_times"]) > 1000:
            self.metrics["response_times"] = self.metrics["response_times"][-1000:]
    
    def get_stats(self) -> Dict[str, Any]:
        """Get current statistics"""
        response_times = self.metrics["response_times"]
        uptime = time.time() - self.start_time
        
        return {
            "uptime_seconds": uptime,
            "requests_total": self.metrics["requests_total"],
            "errors_total": self.metrics["errors_total"],
            "error_rate": self.metrics["errors_total"] / max(self.metrics["requests_total"], 1),
            "requests_per_second": self.metrics["requests_total"] / max(uptime, 1),
            "average_response_time": sum(response_times) / max(len(response_times), 1),
            "active_connections": self.metrics["active_connections"],
            "requests_by_method": self.metrics["requests_by_method"]
        }
    
    def health_check(self) -> Dict[str, Any]:
        """Perform health check"""
        stats = self.get_stats()
        
        # Determine health status
        status = "healthy"
        if stats["error_rate"] > 0.1:  # More than 10% errors
            status = "unhealthy"
        elif stats["average_response_time"] > 5.0:  # Average response time > 5 seconds
            status = "degraded"
        
        return {
            "status": status,
            "timestamp": time.time(),
            "stats": stats
        }
```

This comprehensive MCP documentation covers:

1. **Core Protocol**: Message types, request/response patterns, error handling
2. **Server Implementation**: Tool and resource registration, request handling
3. **Tool Development**: File system, code execution, web API, database tools
4. **Resource Management**: File, directory, and API resources
5. **Client Implementation**: Tool calling, resource reading, session management
6. **Security**: Authentication, rate limiting, message signing
7. **Monitoring**: Metrics, health checks, performance tracking

Each section provides production-ready code examples that demonstrate real-world MCP development patterns.
