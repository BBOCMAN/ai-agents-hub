# General Programming Best Practices and Advanced Concepts

## Design Patterns and Architecture

### Creational Patterns
#### Singleton Pattern
```python
class DatabaseConnection:
    _instance = None
    _connection = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def connect(self, host, port, database):
        if self._connection is None:
            self._connection = f"Connected to {database}@{host}:{port}"
        return self._connection

# Usage
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # True - same instance
```

#### Factory Pattern
```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        animals = {
            'dog': Dog,
            'cat': Cat
        }
        animal_class = animals.get(animal_type.lower())
        if animal_class:
            return animal_class()
        raise ValueError(f"Unknown animal type: {animal_type}")

# Usage
factory = AnimalFactory()
dog = factory.create_animal('dog')
print(dog.make_sound())  # Woof!
```

### Behavioral Patterns
#### Observer Pattern
```python
class Observable:
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        self._observers.append(observer)
    
    def detach(self, observer):
        self._observers.remove(observer)
    
    def notify(self, data):
        for observer in self._observers:
            observer.update(data)

class EmailNotifier:
    def update(self, data):
        print(f"Email sent: {data['message']}")

class SMSNotifier:
    def update(self, data):
        print(f"SMS sent: {data['message']}")

# Usage
notification_system = Observable()
email_notifier = EmailNotifier()
sms_notifier = SMSNotifier()

notification_system.attach(email_notifier)
notification_system.attach(sms_notifier)
notification_system.notify({'message': 'System alert!'})
```

#### Strategy Pattern
```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def process_payment(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number
    
    def process_payment(self, amount):
        return f"Processed ${amount} via Credit Card ending in {self.card_number[-4:]}"

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email
    
    def process_payment(self, amount):
        return f"Processed ${amount} via PayPal account {self.email}"

class PaymentProcessor:
    def __init__(self, strategy: PaymentStrategy):
        self.strategy = strategy
    
    def execute_payment(self, amount):
        return self.strategy.process_payment(amount)

# Usage
processor = PaymentProcessor(CreditCardPayment("1234567890123456"))
print(processor.execute_payment(100))
```

## Advanced Data Structures and Algorithms

### Custom Data Structures
#### Trie (Prefix Tree)
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        current = self.root
        for char in word:
            if char not in current.children:
                current.children[char] = TrieNode()
            current = current.children[char]
        current.is_end_word = True
    
    def search(self, word):
        current = self.root
        for char in word:
            if char not in current.children:
                return False
            current = current.children[char]
        return current.is_end_word
    
    def starts_with(self, prefix):
        current = self.root
        for char in prefix:
            if char not in current.children:
                return False
            current = current.children[char]
        return True
    
    def get_words_with_prefix(self, prefix):
        words = []
        current = self.root
        
        # Navigate to prefix
        for char in prefix:
            if char not in current.children:
                return words
            current = current.children[char]
        
        # DFS to find all words
        def dfs(node, current_word):
            if node.is_end_word:
                words.append(current_word)
            for char, child_node in node.children.items():
                dfs(child_node, current_word + char)
        
        dfs(current, prefix)
        return words

# Usage
trie = Trie()
words = ["apple", "app", "application", "apply", "appreciate"]
for word in words:
    trie.insert(word)

print(trie.get_words_with_prefix("app"))  # ['app', 'apple', 'application', 'apply']
```

#### Graph Implementation with Advanced Algorithms
```python
from collections import defaultdict, deque
import heapq

class Graph:
    def __init__(self, directed=False):
        self.graph = defaultdict(list)
        self.directed = directed
        self.weights = {}
    
    def add_edge(self, u, v, weight=1):
        self.graph[u].append(v)
        self.weights[(u, v)] = weight
        if not self.directed:
            self.graph[v].append(u)
            self.weights[(v, u)] = weight
    
    def bfs(self, start):
        visited = set()
        queue = deque([start])
        result = []
        
        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                visited.add(vertex)
                result.append(vertex)
                queue.extend([neighbor for neighbor in self.graph[vertex] 
                             if neighbor not in visited])
        return result
    
    def dfs(self, start, visited=None):
        if visited is None:
            visited = set()
        
        visited.add(start)
        result = [start]
        
        for neighbor in self.graph[start]:
            if neighbor not in visited:
                result.extend(self.dfs(neighbor, visited))
        
        return result
    
    def dijkstra(self, start):
        distances = {node: float('infinity') for node in self.graph}
        distances[start] = 0
        pq = [(0, start)]
        
        while pq:
            current_distance, current = heapq.heappop(pq)
            
            if current_distance > distances[current]:
                continue
            
            for neighbor in self.graph[current]:
                weight = self.weights.get((current, neighbor), 1)
                distance = current_distance + weight
                
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return distances
    
    def topological_sort(self):
        in_degree = defaultdict(int)
        for u in self.graph:
            for v in self.graph[u]:
                in_degree[v] += 1
        
        queue = deque([node for node in self.graph if in_degree[node] == 0])
        result = []
        
        while queue:
            node = queue.popleft()
            result.append(node)
            
            for neighbor in self.graph[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return result if len(result) == len(self.graph) else None  # Cycle detected

# Usage
g = Graph(directed=True)
g.add_edge('A', 'B', 4)
g.add_edge('A', 'C', 2)
g.add_edge('B', 'C', 1)
g.add_edge('B', 'D', 5)
g.add_edge('C', 'D', 8)

print("BFS:", g.bfs('A'))
print("DFS:", g.dfs('A'))
print("Dijkstra:", g.dijkstra('A'))
print("Topological Sort:", g.topological_sort())
```

## Concurrency and Async Programming

### Threading and Multiprocessing
```python
import threading
import multiprocessing
import concurrent.futures
import time
import queue

class ThreadSafeCounter:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()
    
    def increment(self):
        with self._lock:
            self._value += 1
    
    def get_value(self):
        with self._lock:
            return self._value

def worker_function(counter, num_iterations):
    for _ in range(num_iterations):
        counter.increment()
        time.sleep(0.001)

# Thread Pool Example
def process_with_threads(data):
    counter = ThreadSafeCounter()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(worker_function, counter, 100) for _ in range(4)]
        concurrent.futures.wait(futures)
    
    return counter.get_value()

# Process Pool Example
def cpu_intensive_task(n):
    """Simulate CPU-intensive work"""
    total = 0
    for i in range(n):
        total += i ** 2
    return total

def process_with_multiprocessing(tasks):
    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(cpu_intensive_task, tasks))
    return results

# Producer-Consumer Pattern
class ProducerConsumer:
    def __init__(self, max_size=10):
        self.queue = queue.Queue(max_size)
        self.stop_event = threading.Event()
    
    def producer(self, items):
        for item in items:
            if self.stop_event.is_set():
                break
            self.queue.put(item)
            print(f"Produced: {item}")
            time.sleep(0.1)
    
    def consumer(self, name):
        while not self.stop_event.is_set():
            try:
                item = self.queue.get(timeout=1)
                print(f"Consumer {name} consumed: {item}")
                self.queue.task_done()
            except queue.Empty:
                continue
    
    def run(self, items):
        producer_thread = threading.Thread(target=self.producer, args=(items,))
        consumer_threads = [
            threading.Thread(target=self.consumer, args=(f"C{i}",))
            for i in range(2)
        ]
        
        producer_thread.start()
        for thread in consumer_threads:
            thread.start()
        
        producer_thread.join()
        self.queue.join()
        self.stop_event.set()
        
        for thread in consumer_threads:
            thread.join()

# Usage example (commented to prevent execution)
# pc = ProducerConsumer()
# pc.run(range(20))
```

### Async/Await Programming
```python
import asyncio
import aiohttp
import aiofiles
from typing import List, Dict, Any

class AsyncWebScraper:
    def __init__(self, max_concurrent=10):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def fetch_url(self, url: str) -> Dict[str, Any]:
        async with self.semaphore:
            try:
                async with self.session.get(url) as response:
                    content = await response.text()
                    return {
                        'url': url,
                        'status': response.status,
                        'content_length': len(content),
                        'content': content[:200]  # First 200 chars
                    }
            except Exception as e:
                return {
                    'url': url,
                    'error': str(e),
                    'status': None
                }
    
    async def fetch_multiple(self, urls: List[str]) -> List[Dict[str, Any]]:
        tasks = [self.fetch_url(url) for url in urls]
        return await asyncio.gather(*tasks)

async def async_file_operations():
    """Demonstrate async file operations"""
    # Write to file asynchronously
    async with aiofiles.open('async_test.txt', 'w') as f:
        await f.write("Hello from async file operation!\n")
        await f.write("This is line 2\n")
    
    # Read from file asynchronously
    async with aiofiles.open('async_test.txt', 'r') as f:
        content = await f.read()
        return content

# Async generator example
async def async_number_generator(max_num):
    for i in range(max_num):
        await asyncio.sleep(0.1)  # Simulate async work
        yield i

async def consume_async_generator():
    results = []
    async for number in async_number_generator(5):
        results.append(number)
    return results

# Usage example (commented to prevent execution)
# async def main():
#     # Web scraping example
#     urls = [
#         'https://httpbin.org/delay/1',
#         'https://httpbin.org/delay/2',
#         'https://httpbin.org/json'
#     ]
#     
#     async with AsyncWebScraper() as scraper:
#         results = await scraper.fetch_multiple(urls)
#         for result in results:
#             print(f"URL: {result['url']}, Status: {result.get('status')}")
#     
#     # File operations
#     content = await async_file_operations()
#     print("File content:", content)
#     
#     # Async generator
#     numbers = await consume_async_generator()
#     print("Generated numbers:", numbers)

# asyncio.run(main())
```

## Performance Optimization and Profiling

### Profiling and Benchmarking
```python
import time
import cProfile
import pstats
import functools
from memory_profiler import profile
import tracemalloc

def timing_decorator(func):
    """Decorator to measure function execution time"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

class PerformanceMonitor:
    def __init__(self):
        self.start_time = None
        self.memory_snapshot = None
    
    def __enter__(self):
        # Start timing and memory tracking
        self.start_time = time.perf_counter()
        tracemalloc.start()
        self.memory_snapshot = tracemalloc.take_snapshot()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        # Calculate execution time
        end_time = time.perf_counter()
        execution_time = end_time - self.start_time
        
        # Calculate memory usage
        current_snapshot = tracemalloc.take_snapshot()
        top_stats = current_snapshot.compare_to(self.memory_snapshot, 'lineno')
        
        print(f"Execution time: {execution_time:.4f} seconds")
        print("Top memory allocations:")
        for stat in top_stats[:3]:
            print(stat)
        
        tracemalloc.stop()

@timing_decorator
def inefficient_algorithm(data):
    """Intentionally inefficient nested loop"""
    result = []
    for i in range(len(data)):
        for j in range(len(data)):
            if i != j and data[i] + data[j] > 10:
                result.append((data[i], data[j]))
    return result

@timing_decorator
def optimized_algorithm(data):
    """More efficient approach using sets"""
    result = []
    data_set = set(data)
    for num in data:
        complement = 10 - num + 1  # Looking for pairs that sum > 10
        for candidate in data_set:
            if candidate != num and num + candidate > 10:
                result.append((num, candidate))
                break
    return result

# Profiling functions
def profile_function(func, *args, **kwargs):
    """Profile a function and return stats"""
    profiler = cProfile.Profile()
    profiler.enable()
    
    result = func(*args, **kwargs)
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative')
    stats.print_stats(10)  # Top 10 functions
    
    return result

# Cache optimization
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci_cached(n):
    if n < 2:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

def fibonacci_uncached(n):
    if n < 2:
        return n
    return fibonacci_uncached(n-1) + fibonacci_uncached(n-2)

# Usage examples
def performance_comparison():
    test_data = list(range(1, 21))
    
    print("Performance Comparison:")
    print("=" * 40)
    
    # Compare algorithms
    with PerformanceMonitor():
        result1 = inefficient_algorithm(test_data)
    
    with PerformanceMonitor():
        result2 = optimized_algorithm(test_data)
    
    # Compare cached vs uncached fibonacci
    print("\nFibonacci Comparison (n=30):")
    start = time.perf_counter()
    fib_cached = fibonacci_cached(30)
    cached_time = time.perf_counter() - start
    
    start = time.perf_counter()
    fib_uncached = fibonacci_uncached(30)
    uncached_time = time.perf_counter() - start
    
    print(f"Cached: {cached_time:.6f}s, Result: {fib_cached}")
    print(f"Uncached: {uncached_time:.6f}s, Result: {fib_uncached}")
    print(f"Speedup: {uncached_time / cached_time:.2f}x")

# Uncomment to run performance tests
# performance_comparison()
```

## Error Handling and Logging

### Advanced Exception Handling
```python
import logging
import traceback
import sys
from contextlib import contextmanager
from typing import Type, Optional, Any
from functools import wraps

# Custom exception hierarchy
class ApplicationError(Exception):
    """Base application exception"""
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class ValidationError(ApplicationError):
    """Raised when data validation fails"""
    pass

class ConfigurationError(ApplicationError):
    """Raised when configuration is invalid"""
    pass

class ExternalServiceError(ApplicationError):
    """Raised when external service call fails"""
    def __init__(self, message: str, service_name: str, status_code: int = None):
        self.service_name = service_name
        self.status_code = status_code
        super().__init__(message, f"EXT_{service_name.upper()}_ERROR")

# Retry decorator with exponential backoff
def retry(max_attempts: int = 3, delay: float = 1, backoff: float = 2,
          exceptions: tuple = (Exception,)):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            current_delay = delay
            
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    attempts += 1
                    if attempts == max_attempts:
                        raise
                    
                    logging.warning(f"Attempt {attempts} failed for {func.__name__}: {e}")
                    logging.info(f"Retrying in {current_delay} seconds...")
                    time.sleep(current_delay)
                    current_delay *= backoff
            
            return None
        return wrapper
    return decorator

# Circuit breaker pattern
class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
    
    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if self.state == 'OPEN':
                if time.time() - self.last_failure_time > self.timeout:
                    self.state = 'HALF_OPEN'
                else:
                    raise ExternalServiceError(
                        "Circuit breaker is OPEN", 
                        func.__name__
                    )
            
            try:
                result = func(*args, **kwargs)
                if self.state == 'HALF_OPEN':
                    self.state = 'CLOSED'
                    self.failure_count = 0
                return result
            
            except Exception as e:
                self.failure_count += 1
                self.last_failure_time = time.time()
                
                if self.failure_count >= self.failure_threshold:
                    self.state = 'OPEN'
                
                raise
        
        return wrapper

# Comprehensive logging setup
def setup_logging(level=logging.INFO):
    """Setup comprehensive logging configuration"""
    
    # Create formatters
    detailed_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - '
        '%(filename)s:%(lineno)d - %(funcName)s() - %(message)s'
    )
    
    simple_formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s'
    )
    
    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(simple_formatter)
    console_handler.setLevel(logging.INFO)
    
    file_handler = logging.FileHandler('application.log')
    file_handler.setFormatter(detailed_formatter)
    file_handler.setLevel(logging.DEBUG)
    
    error_handler = logging.FileHandler('errors.log')
    error_handler.setFormatter(detailed_formatter)
    error_handler.setLevel(logging.ERROR)
    
    # Setup root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(error_handler)
    
    return root_logger

@contextmanager
def error_handler(operation_name: str, reraise: bool = True):
    """Context manager for consistent error handling"""
    logger = logging.getLogger(__name__)
    try:
        logger.info(f"Starting operation: {operation_name}")
        yield
        logger.info(f"Completed operation: {operation_name}")
    
    except Exception as e:
        logger.error(f"Error in {operation_name}: {e}")
        logger.debug(f"Full traceback: {traceback.format_exc()}")
        
        if reraise:
            raise
        return None

# Example usage
class DataProcessor:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @retry(max_attempts=3, exceptions=(ExternalServiceError,))
    @CircuitBreaker(failure_threshold=3)
    def fetch_external_data(self, url: str) -> dict:
        """Simulate external API call with error handling"""
        import random
        
        if random.random() < 0.3:  # 30% chance of failure
            raise ExternalServiceError(
                "API temporarily unavailable", 
                "external_api", 
                503
            )
        
        return {"data": f"Success from {url}"}
    
    def process_data(self, data: Any) -> dict:
        """Process data with comprehensive error handling"""
        with error_handler("data_processing"):
            if not data:
                raise ValidationError("Data cannot be empty")
            
            if not isinstance(data, (dict, list)):
                raise ValidationError("Data must be dict or list")
            
            # Simulate processing
            result = {
                "processed": True,
                "items": len(data) if hasattr(data, '__len__') else 1,
                "timestamp": time.time()
            }
            
            self.logger.info(f"Processed {result['items']} items")
            return result

# Usage example
def main_application():
    # Setup logging
    setup_logging()
    logger = logging.getLogger(__name__)
    
    processor = DataProcessor()
    
    # Test data processing
    test_cases = [
        {"valid": "data"},
        [],
        None,
        "invalid_type"
    ]
    
    for i, test_data in enumerate(test_cases):
        try:
            logger.info(f"Processing test case {i + 1}")
            result = processor.process_data(test_data)
            logger.info(f"Result: {result}")
        
        except ApplicationError as e:
            logger.error(f"Application error: {e.message} (Code: {e.error_code})")
        
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
    
    # Test external service calls
    for attempt in range(5):
        try:
            result = processor.fetch_external_data("https://api.example.com/data")
            logger.info(f"External call successful: {result}")
            break
        except ExternalServiceError as e:
            logger.warning(f"External service error: {e.message}")

# Uncomment to run example
# main_application()
```

This comprehensive general programming documentation covers:

1. **Design Patterns**: Singleton, Factory, Observer, Strategy patterns
2. **Advanced Data Structures**: Trie, Graph with algorithms
3. **Concurrency**: Threading, multiprocessing, async/await
4. **Performance**: Profiling, benchmarking, optimization techniques
5. **Error Handling**: Custom exceptions, retry patterns, circuit breakers, logging

Each section includes practical, runnable examples that demonstrate real-world applications of these concepts.
